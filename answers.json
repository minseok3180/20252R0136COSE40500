[
    {
        "id": "1",
        "question": "파이썬에서 리스트와 튜플의 차이점은 무엇인가요?",
        "answer": "파이썬에서 리스트와 튜플은 모두 여러 값을 저장할 수 있는 데이터 구조이지만, 몇 가지 중요한 차이점이 있습니다.\n\n1. **가변성 (Mutability)**:\n   - **리스트**: 가변(mutable)입니다. 즉, 리스트의 내용을 변경할 수 있습니다. 예를 들어, 리스트에 요소를 추가하거나 제거할 수 있습니다.\n     ```python\n     my_list = [1, 2, 3]\n     my_list[0] = 10  # 리스트의 첫 번째 요소를 변경\n     my_list.append(4)  # 요소 추가\n     ```\n   - **튜플**: 불변(immutable)입니다. 즉, 한 번 생성된 튜플의 내용을 변경할 수 없습니다.\n     ```python\n     my_tuple = (1, 2, 3)\n     # my_tuple[0] = 10  # 오류 발생: 'tuple' object does not support item assignment\n     ```\n\n2. **표기법 (Syntax)**:\n   - **리스트**: 대괄호 `[]`를 사용하여 정의합니다.\n     ```python\n     my_list = [1, 2, 3]\n     ```\n   - **튜플**: 소괄호 `()`를 사용하여 정의합니다.\n     ```python\n     my_tuple = (1, 2, 3)\n     ```\n\n3. **성능**:\n   - 튜플은 리스트보다 메모리 사용량이 적고, 일반적으로 더 빠릅니다. 불변성이 있기 때문에 튜플은 해시 가능(hashable)하여, 딕셔너리의 키로 사용될 수 있습니다.\n\n4. **용도**:\n   - 리스트는 주로 변경 가능한 데이터의 집합을 저장할 때 사용됩니다.\n   - 튜플은 변경할 필요가 없는 데이터의 집합을 저장할 때 사용되며, 데이터의 불변성을 보장할 수 있습니다.\n\n5. **내장 함수 및 메서드**:\n   - 리스트는 다양한 메서드(예: `append()`, `remove()`, `pop()`, `sort()`)를 제공합니다.\n   - 튜플은 메서드가 제한적이며, `count()`와 `index()`만을 제공합니다.\n\n이러한 차이점들로 인해 리스트와 튜플은 각각의 용도와 상황에 맞게 선택하여 사용해야 합니다."
    },
    {
        "id": "2",
        "question": "머신러닝에서 과적합(overfitting)을 방지하는 방법은 무엇인가요?",
        "answer": "머신러닝에서 과적합(overfitting)을 방지하기 위한 여러 가지 방법이 있습니다. 다음은 일반적으로 사용되는 몇 가지 방법입니다:\n\n1. **데이터 증강(Data Augmentation)**: 훈련 데이터를 인위적으로 늘려 모델이 다양한 패턴을 학습하도록 합니다. 예를 들어, 이미지 데이터의 경우 회전, 확대, 축소, 색상 변조 등을 통해 다양한 변형을 생성할 수 있습니다.\n\n2. **정규화(Regularization)**: L1 정규화(Lasso)나 L2 정규화(Ridge)와 같은 기법을 사용하여 모델의 복잡성을 줄입니다. 이는 모델이 지나치게 복잡해지는 것을 방지하고 일반화를 돕습니다.\n\n3. **드롭아웃(Dropout)**: 신경망의 특정 뉴런을 훈련 중에 임의로 제외하는 방법입니다. 이는 모델이 특정 뉴런에 의존하지 않도록 하여 일반화 성능을 향상시킵니다.\n\n4. **조기 중단(Early Stopping)**: 검증 데이터의 성능이 더 이상 개선되지 않을 때 훈련을 중단하는 기법입니다. 이를 통해 과적합을 방지할 수 있습니다.\n\n5. **교차 검증(Cross-validation)**: 데이터를 여러 개의 부분으로 나누어 여러 번 훈련하고 검증하는 방법입니다. 이를 통해 모델의 일반화 성능을 평가하고 과적합을 감지할 수 있습니다.\n\n6. **모델 복잡성 감소**: 더 간단한 모델을 사용하거나 모델의 하이퍼파라미터를 조정하여 복잡성을 줄이는 방법입니다.\n\n7. **배치 정규화(Batch Normalization)**: 네트워크의 각 층에 입력을 정규화하여 학습을 안정화하고 과적합을 줄이는 데 도움을 줍니다.\n\n8. **앙상블 기법**: 여러 모델을 결합하여 예측을 수행하는 방법으로, 개별 모델의 약점을 보완하여 과적합을 줄일 수 있습니다.\n\n이러한 방법들을 적절히 조합하여 사용하면 과적합을 효과적으로 방지하고 모델의 일반화 성능을 향상시킬 수 있습니다."
    },
    {
        "id": "3",
        "question": "RESTful API의 주요 특징은 무엇인가요?",
        "answer": "RESTful API(Representational State Transfer API)의 주요 특징은 다음과 같습니다:\n\n1. **무상태성 (Stateless)**:\n   - 클라이언트와 서버 간의 모든 요청은 독립적이어야 하며, 서버는 클라이언트의 상태를 저장하지 않습니다. 각 요청은 필요한 모든 정보를 포함해야 합니다.\n\n2. **자원 기반 (Resource-Oriented)**:\n   - RESTful API는 자원을 URI(Uniform Resource Identifier)로 표현합니다. 각각의 자원은 고유한 URI를 가지며, 클라이언트는 이 URI를 통해 자원에 접근합니다.\n\n3. **HTTP 메서드 사용**:\n   - RESTful API는 HTTP 프로토콜의 메서드를 사용하여 자원에 대한 작업을 수행합니다. 일반적으로 사용되는 메서드는 다음과 같습니다:\n     - GET: 자원 조회\n     - POST: 자원 생성\n     - PUT: 자원 전체 수정\n     - PATCH: 자원 부분 수정\n     - DELETE: 자원 삭제\n\n4. **표현의 전송 (Representation)**:\n   - 자원은 여러 형태(예: JSON, XML, HTML 등)로 표현될 수 있으며, 클라이언트는 원하는 형식을 요청할 수 있습니다. 서버는 요청된 형식으로 자원을 반환합니다.\n\n5. **계층화된 시스템 (Layered System)**:\n   - REST 아키텍처는 클라이언트와 서버 간의 통신을 중개하는 여러 레이어를 가질 수 있습니다. 클라이언트는 중간 레이어가 존재하는지 모르게 통신할 수 있습니다.\n\n6. **캐시 가능 (Cacheable)**:\n   - 서버는 응답에 캐시 가능 여부를 명시할 수 있으며, 클라이언트는 이를 활용하여 성능을 개선할 수 있습니다. 캐시된 데이터는 서버에 대한 요청 수를 줄여줍니다.\n\n7. **인터페이스의 일관성**:\n   - RESTful API는 통일된 인터페이스를 통해 클라이언트와 서버 간의 상호작용을 단순화합니다. 이는 API의 사용성과 유지보수성을 높이는 데 기여합니다.\n\n이러한 특징들은 RESTful API가 클라이언트-서버 아키텍처의 장점을 활용하여 확장성과 유연성을 제공하는 데 중요한 역할을 합니다."
    }
]